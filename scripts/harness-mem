#!/bin/bash
# Unified Harness Memory helper CLI.
#
# Usage:
#   scripts/harness-mem setup [--project <path>] [--platform <all|codex|opencode|claude|cursor|codex,cursor>] [--skip-start] [--skip-smoke] [--skip-quality]
#   scripts/harness-mem doctor [--project <path>] [--platform <all|codex|opencode|claude|cursor|codex,cursor>] [--fix]
#   scripts/harness-mem smoke [--project <path>]
#   scripts/harness-mem uninstall [--project <path>] [--platform <all|codex|opencode|claude|cursor|codex,cursor>] [--purge-db]
#   scripts/harness-mem import-claude-mem --source <claude_mem.db> [--dry-run] [--import-project <name>]
#   scripts/harness-mem verify-import --job <job_id>
#   scripts/harness-mem cutover-claude-mem --job <job_id> --stop-now

set -euo pipefail
IFS=$'\n\t'

SCRIPT_SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_SOURCE" ]; do
  SCRIPT_SOURCE_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
  SCRIPT_TARGET="$(readlink "$SCRIPT_SOURCE")"
  if [[ "$SCRIPT_TARGET" != /* ]]; then
    SCRIPT_SOURCE="${SCRIPT_SOURCE_DIR}/${SCRIPT_TARGET}"
  else
    SCRIPT_SOURCE="$SCRIPT_TARGET"
  fi
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
SOURCE_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
HARNESS_ROOT="$SOURCE_ROOT"

TARGET_DIR="${HARNESS_MEM_TARGET_DIR:-$PWD}"
PLATFORM="all"
PLATFORM_EXPLICIT=0
UI_LANG="${HARNESS_MEM_LANG:-ja}"
SETUP_INTERACTIVE_PROMPT_USED=0
SETUP_IMPORT_CLAUDE_MEM=0
SETUP_STOP_CLAUDE_MEM_AFTER_IMPORT=0
FIX_MODE=0
PURGE_DB=0
SKIP_START=0
SKIP_SMOKE=0
SKIP_QUALITY=0
QUIET=0
IMPORT_SOURCE=""
IMPORT_JOB_ID=""
IMPORT_PROJECT=""
IMPORT_DRY_RUN=0
STOP_NOW=0

MEM_HOST="${HARNESS_MEM_HOST:-127.0.0.1}"
MEM_PORT="${HARNESS_MEM_PORT:-37888}"
STATE_DIR="${HARNESS_MEM_HOME:-$HOME/.harness-mem}"
DB_PATH="${HARNESS_MEM_DB_PATH:-$STATE_DIR/harness-mem.db}"

BEGIN_CODEX_NOTIFY="# >>> harness-mem codex notify"
END_CODEX_NOTIFY="# <<< harness-mem codex notify"
BEGIN_CODEX_MCP="# >>> harness-mem codex mcp"
END_CODEX_MCP="# <<< harness-mem codex mcp"

usage() {
  cat <<'EOF'
Unified Harness Memory helper

Commands:
  setup      Configure Codex/OpenCode/Cursor/Claude wiring, start daemon, run smoke and quality checks.
  doctor     Validate wiring and daemon health (optionally repair with --fix).
  smoke      Run isolated daemon smoke test against record/search privacy flow.
  uninstall  Remove memory wiring and optionally purge local memory DB.
  import-claude-mem  One-shot import from Claude-mem SQLite into harness-mem.
  verify-import      Verify imported data quality/privacy checks by job id.
  cutover-claude-mem Stop Claude-mem only after verify passed.

Common options:
  --project <path>      Target project path (default: current directory)
  --platform <value>    all|codex|opencode|claude|cursor or comma list (default: all)
                        examples: codex,cursor  /  opencode,cursor
  --source <path>       Source SQLite path for import-claude-mem
  --job <job_id>        Import job id for verify/cutover
  --import-project <s>  Override project name on import
  --dry-run             Plan import without writing events
  --stop-now            Required by cutover-claude-mem to actually stop Claude-mem
  --quiet               Reduce logs

Command options:
  setup:
    --skip-start        Do not start daemon
    --skip-smoke        Do not run smoke test
    --skip-quality      Do not run search quality test
    (no --platform)     Interactive setup prompt:
                        1) language (Japanese/English)
                        2) target tools (multi-select)
                        3) import from Claude-mem (yes/no)
                        4) stop Claude-mem after import (yes/no)
  doctor:
    --fix               Attempt to repair missing wiring
  uninstall:
    --purge-db          Remove ~/.harness-mem/harness-mem.db after stop
EOF
}

log() {
  if [ "$QUIET" -eq 1 ]; then
    return
  fi
  echo "[harness-mem] $*"
}

warn() {
  if [ "$QUIET" -eq 1 ]; then
    return
  fi
  echo "[harness-mem][warn] $*" >&2
}

fail() {
  echo "[harness-mem][error] $*" >&2
  exit 1
}

abs_dir() {
  local input="$1"
  if [ -d "$input" ]; then
    (cd "$input" && pwd)
    return
  fi
  fail "Directory not found: $input"
}

parse_options() {
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --project)
        shift
        [ "$#" -gt 0 ] || fail "--project requires a path"
        TARGET_DIR="$1"
        ;;
      --platform)
        shift
        [ "$#" -gt 0 ] || fail "--platform requires a value"
        PLATFORM="$1"
        PLATFORM_EXPLICIT=1
        ;;
      --fix)
        FIX_MODE=1
        ;;
      --purge-db)
        PURGE_DB=1
        ;;
      --skip-start)
        SKIP_START=1
        ;;
      --skip-smoke)
        SKIP_SMOKE=1
        ;;
      --skip-quality)
        SKIP_QUALITY=1
        ;;
      --quiet)
        QUIET=1
        ;;
      --source)
        shift
        [ "$#" -gt 0 ] || fail "--source requires a path"
        IMPORT_SOURCE="$1"
        ;;
      --job)
        shift
        [ "$#" -gt 0 ] || fail "--job requires a value"
        IMPORT_JOB_ID="$1"
        ;;
      --import-project)
        shift
        [ "$#" -gt 0 ] || fail "--import-project requires a value"
        IMPORT_PROJECT="$1"
        ;;
      --dry-run)
        IMPORT_DRY_RUN=1
        ;;
      --stop-now)
        STOP_NOW=1
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        fail "Unknown option: $1"
        ;;
    esac
    shift
  done
}

csv_has_value() {
  local csv="$1"
  local needle="$2"
  local item
  IFS=',' read -r -a items <<<"$csv"
  for item in "${items[@]}"; do
    local normalized
    normalized="$(printf '%s' "$item" | xargs)"
    if [ "$normalized" = "$needle" ]; then
      return 0
    fi
  done
  return 1
}

csv_append_unique() {
  local csv="$1"
  local value="$2"
  if [ -z "$csv" ]; then
    printf '%s' "$value"
    return
  fi
  if csv_has_value "$csv" "$value"; then
    printf '%s' "$csv"
    return
  fi
  printf '%s,%s' "$csv" "$value"
}

normalize_ui_lang() {
  case "$UI_LANG" in
    en|EN|english|English)
      UI_LANG="en"
      ;;
    *)
      UI_LANG="ja"
      ;;
  esac
}

ui_is_en() {
  [ "$UI_LANG" = "en" ]
}

should_prompt_platform_selection() {
  local command="$1"
  if [ "$command" != "setup" ]; then
    return 1
  fi
  if [ "$PLATFORM_EXPLICIT" -eq 1 ]; then
    return 1
  fi
  if [ "${HARNESS_MEM_NON_INTERACTIVE:-0}" = "1" ]; then
    return 1
  fi
  if [ -t 0 ] || [ "${HARNESS_MEM_FORCE_PLATFORM_PROMPT:-0}" = "1" ]; then
    return 0
  fi
  return 1
}

prompt_platform_selection() {
  local input choices token selected valid
  while true; do
    if ui_is_en; then
      cat <<'EOF'
[harness-mem] Select setup targets (multiple allowed)
  1) codex     (global: ~/.codex/config.toml)
  2) cursor    (global: ~/.cursor/hooks.json + ~/.cursor/mcp.json)
  3) opencode  (global: ~/.config/opencode/opencode.json)
  4) claude    (global: ~/.claude.json mcpServers)
  a) all
Example: 1,2   (Enter=1,2)
EOF
    else
      cat <<'EOF'
[harness-mem] setup 対象を選択してください（複数可）
  1) codex     (global: ~/.codex/config.toml)
  2) cursor    (global: ~/.cursor/hooks.json + ~/.cursor/mcp.json)
  3) opencode  (global: ~/.config/opencode/opencode.json)
  4) claude    (global: ~/.claude.json mcpServers)
  a) all
入力例: 1,2   (Enter=1,2)
EOF
    fi
    printf "> "
    read -r input || input=""
    input="$(printf '%s' "$input" | tr -d '[:space:]')"

    if [ -z "$input" ]; then
      PLATFORM="codex,cursor"
      log "Selected platforms: $PLATFORM"
      return
    fi

    case "$input" in
      a|A|all|ALL)
        PLATFORM="all"
        log "Selected platforms: $PLATFORM"
        return
        ;;
    esac

    selected=""
    valid=1
    IFS=',' read -r -a choices <<<"$input"
    for token in "${choices[@]}"; do
      case "$token" in
        1|codex)
          selected="$(csv_append_unique "$selected" "codex")"
          ;;
        2|cursor)
          selected="$(csv_append_unique "$selected" "cursor")"
          ;;
        3|opencode)
          selected="$(csv_append_unique "$selected" "opencode")"
          ;;
        4|claude)
          selected="$(csv_append_unique "$selected" "claude")"
          ;;
        *)
          if ui_is_en; then
            warn "Invalid selection: ${token}. Use 1,2,3,4 or a"
          else
            warn "無効な選択: ${token}。1,2,3,4 または a を入力してください"
          fi
          valid=0
          ;;
      esac
    done

    if [ "$valid" -eq 1 ] && [ -n "$selected" ]; then
      PLATFORM="$selected"
      log "Selected platforms: $PLATFORM"
      return
    fi
  done
}

prompt_language_selection() {
  local input
  while true; do
    cat <<'EOF'
[harness-mem] 言語を選択してください / Select language
  1) 日本語
  2) English
入力例: 1   (Enter=1)
EOF
    printf "> "
    read -r input || input=""
    input="$(printf '%s' "$input" | tr -d '[:space:]')"
    case "$input" in
      ""|1|ja|JA|jp|JP|japanese|Japanese)
        UI_LANG="ja"
        log "言語を日本語に設定しました"
        return
        ;;
      2|en|EN|english|English)
        UI_LANG="en"
        log "Language set to English"
        return
        ;;
      *)
        warn "Invalid selection: ${input}. Use 1 or 2"
        ;;
    esac
  done
}

prompt_yes_no_default_no() {
  local question="$1"
  local answer=""
  while true; do
    printf "%s [y/N]: " "$question"
    read -r answer || answer=""
    answer="$(printf '%s' "$answer" | tr -d '[:space:]')"
    if [ -z "$answer" ]; then
      return 1
    fi
    case "$answer" in
      y|Y|yes|YES|Yes)
        return 0
        ;;
      n|N|no|NO|No)
        return 1
        ;;
      *)
        if ui_is_en; then
          warn "Invalid input: ${answer}. Use y or n"
        else
          warn "無効な入力: ${answer}。y または n を入力してください"
        fi
        ;;
    esac
  done
}

should_prompt_setup_migration_selection() {
  local command="$1"
  if [ "$command" != "setup" ]; then
    return 1
  fi
  if [ "$SETUP_INTERACTIVE_PROMPT_USED" -ne 1 ]; then
    return 1
  fi
  return 0
}

prompt_setup_migration_selection() {
  local import_question stop_question
  if ui_is_en; then
    import_question="Import existing data from Claude-mem?"
    stop_question="Stop Claude-mem after import completes?"
  else
    import_question="Claude-memから既存データをインポートしますか?"
    stop_question="インポート完了後にClaude-memを停止しますか?"
  fi

  if prompt_yes_no_default_no "$import_question"; then
    SETUP_IMPORT_CLAUDE_MEM=1
    if prompt_yes_no_default_no "$stop_question"; then
      SETUP_STOP_CLAUDE_MEM_AFTER_IMPORT=1
    fi
  fi

  log "Migration options: import_claude_mem=${SETUP_IMPORT_CLAUDE_MEM}, stop_after_import=${SETUP_STOP_CLAUDE_MEM_AFTER_IMPORT}"
}

is_platform_enabled() {
  local target="$1"
  if [ "$target" = "antigravity" ]; then
    return 1
  fi
  local entry
  IFS=',' read -r -a entries <<<"$PLATFORM"
  for entry in "${entries[@]}"; do
    local normalized
    normalized="$(printf '%s' "$entry" | xargs)"
    [ -z "$normalized" ] && continue
    if [ "$normalized" = "all" ] || [ "$normalized" = "$target" ]; then
      return 0
    fi
  done
  return 1
}

validate_platform_selection() {
  local entry
  local seen=0
  IFS=',' read -r -a entries <<<"$PLATFORM"
  for entry in "${entries[@]}"; do
    local normalized
    normalized="$(printf '%s' "$entry" | xargs)"
    [ -z "$normalized" ] && continue
    case "$normalized" in
      all|codex|opencode|claude|cursor)
        seen=1
        ;;
      *)
        fail "Invalid --platform entry: ${normalized} (allowed: all,codex,opencode,claude,cursor)"
        ;;
    esac
  done
  [ "$seen" -eq 1 ] || fail "Invalid --platform: ${PLATFORM}"
}

require_cmd() {
  local name="$1"
  if ! command -v "$name" >/dev/null 2>&1; then
    fail "Required command not found: $name"
  fi
}

should_use_stable_runtime_root() {
  case "$SOURCE_ROOT" in
    */.npm/_npx/*)
      return 0
      ;;
  esac
  return 1
}

sync_to_stable_runtime_root() {
  local runtime_root="${STATE_DIR}/runtime/harness-mem"

  mkdir -p "${STATE_DIR}/runtime"

  if check_cmd rsync; then
    rsync -a --delete --exclude '.git' "${SOURCE_ROOT}/" "${runtime_root}/"
  else
    rm -rf "${runtime_root}"
    mkdir -p "${runtime_root}"
    cp -R "${SOURCE_ROOT}/." "${runtime_root}/"
    rm -rf "${runtime_root}/.git"
  fi

  HARNESS_ROOT="${runtime_root}"
  log "Using stable runtime root: ${HARNESS_ROOT}"
}

check_cmd() {
  local name="$1"
  command -v "$name" >/dev/null 2>&1
}

get_cursor_hooks_command() {
  printf '%s' "bash ${HOME}/.cursor/hooks/memory-cursor-event.sh"
}

ensure_dependencies() {
  require_cmd bun
  require_cmd curl
  require_cmd jq
  require_cmd node
  require_cmd npm
}

ensure_mcp_runtime() {
  local mcp_dir="${HARNESS_ROOT}/mcp-server"
  local mcp_dist="${mcp_dir}/dist/index.js"
  local mcp_sdk_local="${mcp_dir}/node_modules/@modelcontextprotocol/sdk/package.json"
  local mcp_sdk_root="${HARNESS_ROOT}/node_modules/@modelcontextprotocol/sdk/package.json"
  local mcp_src_entry="${mcp_dir}/src/index.ts"

  if [ ! -f "$mcp_dist" ]; then
    [ -f "$mcp_src_entry" ] || fail "MCP dist entry missing and source unavailable: $mcp_dist"
    log "MCP dist entry missing. Bootstrapping local MCP build."
    (
      cd "$mcp_dir"
      npm install --silent
      npm run build --silent
    )
  fi

  [ -f "$mcp_dist" ] || fail "MCP dist build failed: $mcp_dist"

  if [ -f "$mcp_sdk_local" ] || [ -f "$mcp_sdk_root" ]; then
    return
  fi

  log "Installing MCP server dependencies (one-time)"
  (
    cd "$mcp_dir"
    npm install --silent
  )
}

remove_marked_block() {
  local file="$1"
  local begin="$2"
  local end="$3"
  local tmp
  tmp="$(mktemp)"
  awk -v begin="$begin" -v end="$end" '
    index($0, begin) { skip = 1; next }
    index($0, end) { skip = 0; next }
    skip != 1 { print $0 }
  ' "$file" >"$tmp"
  mv "$tmp" "$file"
}

setup_codex_wiring() {
  local codex_dir="${HOME}/.codex"
  local cfg="${codex_dir}/config.toml"
  local rules_src="${HARNESS_ROOT}/codex/.codex/rules/harness.rules"
  local rules_dst="${codex_dir}/rules/harness.rules"
  local notify_value="bash ${HARNESS_ROOT}/scripts/hook-handlers/memory-codex-notify.sh"

  mkdir -p "$codex_dir"

  if [ ! -f "$cfg" ]; then
    cat >"$cfg" <<EOF
# Codex Team Config (generated by harness-mem)

$BEGIN_CODEX_NOTIFY
notify = "${notify_value}"
$END_CODEX_NOTIFY

$BEGIN_CODEX_MCP
[mcp_servers.harness]
command = "node"
args = ["${HARNESS_ROOT}/mcp-server/dist/index.js"]
enabled = true

[mcp_servers.harness.env]
HARNESS_MEM_HOST = "${MEM_HOST}"
HARNESS_MEM_PORT = "${MEM_PORT}"
HARNESS_MEM_DB_PATH = "${DB_PATH}"
$END_CODEX_MCP
EOF
    log "Created Codex config: $cfg"
  else
    if ! rg -q 'memory-codex-notify\.sh' "$cfg"; then
      if rg -q '^\s*notify\s*=' "$cfg"; then
        warn "Codex config already has notify=. Add memory notify manually: $cfg"
      else
        cat >>"$cfg" <<EOF

$BEGIN_CODEX_NOTIFY
notify = "${notify_value}"
$END_CODEX_NOTIFY
EOF
        log "Added Codex notify wiring: $cfg"
      fi
    fi

    if rg -q 'notify[[:space:]]*=[[:space:]]*\[[[:space:]]*"bash"[[:space:]]*,[[:space:]]*".*memory-codex-notify\.sh"[[:space:]]*\]' "$cfg"; then
      local tmp
      tmp="$(mktemp)"
      sed -E 's|notify[[:space:]]*=[[:space:]]*\[[[:space:]]*"bash"[[:space:]]*,[[:space:]]*"([^"]*memory-codex-notify\.sh)"[[:space:]]*\]|notify = "bash \1"|' "$cfg" >"$tmp"
      mv "$tmp" "$cfg"
      log "Normalized Codex notify wiring format: $cfg"
    fi

    if ! rg -q '^\[mcp_servers\.harness\]' "$cfg"; then
      cat >>"$cfg" <<EOF

$BEGIN_CODEX_MCP
[mcp_servers.harness]
command = "node"
args = ["${HARNESS_ROOT}/mcp-server/dist/index.js"]
enabled = true

[mcp_servers.harness.env]
HARNESS_MEM_HOST = "${MEM_HOST}"
HARNESS_MEM_PORT = "${MEM_PORT}"
HARNESS_MEM_DB_PATH = "${DB_PATH}"
$END_CODEX_MCP
EOF
      log "Added Codex MCP wiring: $cfg"
    fi
  fi

  if [ -f "$rules_src" ] && [ ! -f "$rules_dst" ]; then
    mkdir -p "$(dirname "$rules_dst")"
    cp "$rules_src" "$rules_dst"
    log "Copied memory-aware Codex rules: $rules_dst"
  fi
}

check_codex_wiring() {
  local cfg="${HOME}/.codex/config.toml"
  local failed=0

  if [ ! -f "$cfg" ]; then
    warn "Missing Codex config: $cfg"
    return 1
  fi

  if rg -q 'memory-codex-notify\.sh' "$cfg"; then
    log "Codex notify wiring: OK"
  else
    warn "Codex notify wiring is missing in: $cfg"
    failed=1
  fi

  if rg -q '^\[mcp_servers\.harness\]' "$cfg"; then
    log "Codex MCP wiring: OK"
  else
    warn "Codex MCP wiring is missing in: $cfg"
    failed=1
  fi

  return "$failed"
}

get_claude_config_targets() {
  local primary="${HOME}/.claude.json"
  local secondary="${HOME}/.claude/settings.json"
  local emitted=0

  if [ -f "$primary" ]; then
    printf '%s\n' "$primary"
    emitted=1
  fi

  if [ -f "$secondary" ]; then
    if jq -e 'has("mcpServers")' "$secondary" >/dev/null 2>&1; then
      printf '%s\n' "$secondary"
      emitted=1
    fi
  fi

  if [ "$emitted" -eq 0 ]; then
    printf '%s\n' "$primary"
  fi
}

upsert_claude_json() {
  local file="$1"
  local mcp_entry="${HARNESS_ROOT}/mcp-server/dist/index.js"
  local tmp

  mkdir -p "$(dirname "$file")"

  if [ ! -f "$file" ]; then
    cat >"$file" <<'EOF'
{
  "mcpServers": {}
}
EOF
    log "Created Claude config: $file"
  fi

  tmp="$(mktemp)"
  if jq \
    --arg mcp_entry "$mcp_entry" \
    --arg host "$MEM_HOST" \
    --arg port "$MEM_PORT" \
    --arg db_path "$DB_PATH" \
    '
      .mcpServers = (.mcpServers // {})
      | .mcpServers.harness = (.mcpServers.harness // {})
      | .mcpServers.harness.command = "node"
      | .mcpServers.harness.args = [$mcp_entry]
      | .mcpServers.harness.enabled = true
      | .mcpServers.harness.env = ((.mcpServers.harness.env // {}) + {
          "HARNESS_MEM_HOST": $host,
          "HARNESS_MEM_PORT": $port,
          "HARNESS_MEM_DB_PATH": $db_path
        })
    ' "$file" >"$tmp" 2>/dev/null; then
    mv "$tmp" "$file"
    log "Updated Claude MCP wiring: $file"
    return 0
  fi

  rm -f "$tmp"
  warn "Could not parse Claude config JSON: $file"
  return 1
}

setup_claude_wiring() {
  local failed=0
  local any_target=0
  while IFS= read -r cfg; do
    [ -n "$cfg" ] || continue
    any_target=1
    upsert_claude_json "$cfg" || failed=1
  done < <(get_claude_config_targets)

  if [ "$any_target" -eq 0 ] || [ "$failed" -ne 0 ]; then
    fail "Failed to set up Claude MCP wiring"
  fi
}

upsert_cursor_hooks_json() {
  local file="$1"
  local hook_command="$2"
  local tmp
  local template="${HARNESS_ROOT}/.cursor/hooks.json.example"

  mkdir -p "$(dirname "$file")"

  if [ ! -f "$file" ]; then
    if [ -f "$template" ]; then
      cp "$template" "$file"
    else
      cat >"$file" <<EOF
{
  "version": 1,
  "hooks": {
    "beforeSubmitPrompt": [
      { "command": "${hook_command}" }
    ],
    "afterMCPExecution": [
      { "command": "${hook_command}" }
    ],
    "afterShellExecution": [
      { "command": "${hook_command}" }
    ],
    "afterFileEdit": [
      { "command": "${hook_command}" }
    ],
    "stop": [
      { "command": "${hook_command}" }
    ]
  }
}
EOF
    fi
    log "Created Cursor hooks config: $file"
  fi

  tmp="$(mktemp)"
  if jq --arg cmd "$hook_command" '
    .version = (.version // 1)
    | .hooks = (.hooks // {})
    | .hooks.beforeSubmitPrompt = (
        (
          (.hooks.beforeSubmitPrompt // [])
          | map(if type == "object" then . else {} end)
          | map(select(((.command // "") | contains("memory-cursor-event.sh")) | not))
        ) + [{command:$cmd}]
        | unique_by(.command)
      )
    | .hooks.afterMCPExecution = (
        (
          (.hooks.afterMCPExecution // [])
          | map(if type == "object" then . else {} end)
          | map(select(((.command // "") | contains("memory-cursor-event.sh")) | not))
        ) + [{command:$cmd}]
        | unique_by(.command)
      )
    | .hooks.afterShellExecution = (
        (
          (.hooks.afterShellExecution // [])
          | map(if type == "object" then . else {} end)
          | map(select(((.command // "") | contains("memory-cursor-event.sh")) | not))
        ) + [{command:$cmd}]
        | unique_by(.command)
      )
    | .hooks.afterFileEdit = (
        (
          (.hooks.afterFileEdit // [])
          | map(if type == "object" then . else {} end)
          | map(select(((.command // "") | contains("memory-cursor-event.sh")) | not))
        ) + [{command:$cmd}]
        | unique_by(.command)
      )
    | .hooks.stop = (
        (
          (.hooks.stop // [])
          | map(if type == "object" then . else {} end)
          | map(select(((.command // "") | contains("memory-cursor-event.sh")) | not))
        ) + [{command:$cmd}]
        | unique_by(.command)
      )
  ' "$file" >"$tmp" 2>/dev/null; then
    mv "$tmp" "$file"
    log "Updated Cursor hooks config: $file"
  else
    rm -f "$tmp"
    warn "Could not parse Cursor hooks JSON: $file"
  fi
}

setup_cursor_hook_script() {
  local script_path="${HOME}/.cursor/hooks/memory-cursor-event.sh"
  local template="${HARNESS_ROOT}/.cursor/hooks/memory-cursor-event.sh"

  mkdir -p "$(dirname "$script_path")"

  if [ -f "$template" ]; then
    cp "$template" "$script_path"
  else
    cat >"$script_path" <<'EOF'
#!/bin/bash
set +e
exit 0
EOF
  fi

  local escaped_root
  escaped_root="$(printf '%s' "$HARNESS_ROOT" | sed 's/[\/&]/\\&/g')"
  local tmp
  tmp="$(mktemp)"
  sed "s/__HARNESS_ROOT__/${escaped_root}/g" "$script_path" >"$tmp"
  mv "$tmp" "$script_path"
  chmod +x "$script_path"
}

setup_cursor_wiring() {
  local hooks_json="${HOME}/.cursor/hooks.json"
  local mcp_json="${HOME}/.cursor/mcp.json"
  local hook_command
  hook_command="$(get_cursor_hooks_command)"
  setup_cursor_hook_script
  upsert_cursor_hooks_json "$hooks_json" "$hook_command"
  upsert_cursor_mcp_json "$mcp_json"
}

upsert_cursor_mcp_json() {
  local file="$1"
  local mcp_entry="${HARNESS_ROOT}/mcp-server/dist/index.js"
  local tmp

  mkdir -p "$(dirname "$file")"

  if [ ! -f "$file" ]; then
    cat >"$file" <<'EOF'
{
  "mcpServers": {}
}
EOF
    log "Created Cursor MCP config: $file"
  fi

  tmp="$(mktemp)"
  if jq \
    --arg mcp_entry "$mcp_entry" \
    --arg host "$MEM_HOST" \
    --arg port "$MEM_PORT" \
    --arg db_path "$DB_PATH" \
    '
      .mcpServers = (.mcpServers // {})
      | .mcpServers.harness = (.mcpServers.harness // {})
      | .mcpServers.harness.type = (.mcpServers.harness.type // "stdio")
      | .mcpServers.harness.command = "node"
      | .mcpServers.harness.args = [$mcp_entry]
      | .mcpServers.harness.env = ((.mcpServers.harness.env // {}) + {
          "HARNESS_MEM_HOST": $host,
          "HARNESS_MEM_PORT": $port,
          "HARNESS_MEM_DB_PATH": $db_path
        })
    ' "$file" >"$tmp" 2>/dev/null; then
    mv "$tmp" "$file"
    log "Updated Cursor MCP wiring: $file"
    return 0
  fi

  rm -f "$tmp"
  warn "Could not parse Cursor MCP JSON: $file"
  return 1
}

check_cursor_wiring() {
  local hooks_json="${HOME}/.cursor/hooks.json"
  local mcp_json="${HOME}/.cursor/mcp.json"
  local hook_script="${HOME}/.cursor/hooks/memory-cursor-event.sh"
  local mcp_entry="${HARNESS_ROOT}/mcp-server/dist/index.js"
  local hook_command
  hook_command="$(get_cursor_hooks_command)"
  local failed=0

  if [ ! -f "$hook_script" ]; then
    warn "Cursor hook script missing: $hook_script"
    failed=1
  else
    log "Cursor hook script: OK"
  fi

  if [ ! -f "$hooks_json" ]; then
    warn "Cursor hooks config missing: $hooks_json"
    failed=1
  else
    if jq -e --arg cmd "$hook_command" '
      (.hooks.beforeSubmitPrompt // [] | any((.command // "") == $cmd or ((.command // "") | contains("memory-cursor-event.sh"))))
      and (.hooks.afterMCPExecution // [] | any((.command // "") == $cmd or ((.command // "") | contains("memory-cursor-event.sh"))))
      and (.hooks.afterShellExecution // [] | any((.command // "") == $cmd or ((.command // "") | contains("memory-cursor-event.sh"))))
      and (.hooks.afterFileEdit // [] | any((.command // "") == $cmd or ((.command // "") | contains("memory-cursor-event.sh"))))
      and (.hooks.stop // [] | any((.command // "") == $cmd or ((.command // "") | contains("memory-cursor-event.sh"))))
    ' "$hooks_json" >/dev/null 2>&1; then
      log "Cursor hooks JSON wiring: OK"
    else
      warn "Cursor hooks wiring is incomplete: $hooks_json"
      failed=1
    fi
  fi

  if [ ! -f "$mcp_json" ]; then
    warn "Cursor MCP config missing: $mcp_json"
    failed=1
  else
    if jq -e --arg mcp_entry "$mcp_entry" '
      .mcpServers.harness != null
      and (
        (
          (.mcpServers.harness.command // "") == "node"
          and ((.mcpServers.harness.args // []) | any(. == $mcp_entry))
        )
        or (
          (.mcpServers.harness.command // "") == "npx"
          and ((.mcpServers.harness.args // []) | any((. | tostring) | contains("harness-mcp-server") or contains("harness-mem")))
        )
      )
    ' "$mcp_json" >/dev/null 2>&1; then
      log "Cursor MCP wiring: OK"
    else
      warn "Cursor MCP wiring is incomplete: $mcp_json"
      failed=1
    fi
  fi

  return "$failed"
}

setup_antigravity_wiring() {
  log "Antigravity ingest uses workspace file scanning (docs/checkpoints + logs/codex-responses)"
}

check_antigravity_wiring() {
  local roots="${HARNESS_MEM_ANTIGRAVITY_ROOTS:-}"
  if [ -z "$roots" ]; then
    log "Antigravity roots are not explicitly configured (auto-discovery mode)"
    return 0
  fi

  local failed=0
  local IFS=','
  for raw in $roots; do
    local root
    root="$(printf '%s' "$raw" | xargs)"
    [ -z "$root" ] && continue
    if [ -d "$root" ]; then
      log "Antigravity root: OK ($root)"
    else
      warn "Antigravity root not found: $root"
      failed=1
    fi
  done
  return "$failed"
}

print_post_setup_next_steps() {
  log "Next step: verify wiring with doctor"
  log "  ./scripts/harness-mem doctor --project ${TARGET_DIR} --platform ${PLATFORM}"

  if is_platform_enabled cursor; then
    local hooks_json="${HOME}/.cursor/hooks.json"
    local mcp_json="${HOME}/.cursor/mcp.json"
    if [ -f "$hooks_json" ]; then
      log "Cursor wiring file: ${hooks_json}"
    else
      warn "Cursor wiring file is missing: ${hooks_json}"
    fi
    if [ -f "$mcp_json" ]; then
      log "Cursor MCP file: ${mcp_json}"
    else
      warn "Cursor MCP file is missing: ${mcp_json}"
    fi
    log "Cursor verification: send one prompt in Cursor, then check feed"
    log "  curl -sS 'http://${MEM_HOST}:${MEM_PORT}/v1/feed?project=$(basename "$TARGET_DIR")&limit=5&include_private=false' | jq '.ok, .meta.count'"
  fi

  if is_platform_enabled antigravity; then
    if [ -z "${HARNESS_MEM_ANTIGRAVITY_ROOTS:-}" ]; then
      log "Antigravity roots: auto-discovery from Antigravity workspaceStorage"
      log "  (optional) export HARNESS_MEM_ANTIGRAVITY_ROOTS=/absolute/path/to/antigravity-workspace"
    else
      log "Antigravity roots: ${HARNESS_MEM_ANTIGRAVITY_ROOTS}"
    fi
  fi
}

upsert_opencode_json() {
  local file="$1"
  local mcp_entry="${HARNESS_ROOT}/mcp-server/dist/index.js"
  local tmp

  mkdir -p "$(dirname "$file")"

  if [ ! -f "$file" ]; then
    cat >"$file" <<EOF
{
  "\$schema": "https://opencode.ai/config.json",
  "mcp": {
    "harness": {
      "type": "local",
      "enabled": true,
      "command": ["node", "${mcp_entry}"],
      "environment": {
        "HARNESS_MEM_HOST": "${MEM_HOST}",
        "HARNESS_MEM_PORT": "${MEM_PORT}",
        "HARNESS_MEM_DB_PATH": "${DB_PATH}"
      }
    }
  }
}
EOF
    log "Created OpenCode config: $file"
    return
  fi

  tmp="$(mktemp)"
  jq \
    --arg mcp_entry "$mcp_entry" \
    --arg host "$MEM_HOST" \
    --arg port "$MEM_PORT" \
    --arg db_path "$DB_PATH" \
    '
      .["$schema"] = (.["$schema"] // "https://opencode.ai/config.json")
      | .mcp = (.mcp // {})
      | .mcp.harness = (.mcp.harness // {})
      | .mcp.harness.type = "local"
      | .mcp.harness.enabled = true
      | .mcp.harness.command = ["node", $mcp_entry]
      | .mcp.harness.environment = ((.mcp.harness.environment // {}) + {
          "HARNESS_MEM_HOST": $host,
          "HARNESS_MEM_PORT": $port,
          "HARNESS_MEM_DB_PATH": $db_path
        })
      | .mcp.harness |= del(.env)
      | del(.plugins)
    ' "$file" >"$tmp"
  mv "$tmp" "$file"
  log "Updated OpenCode config: $file"
}

setup_opencode_wiring() {
  local opencode_dir="${HOME}/.config/opencode"
  local plugin_src="${HARNESS_ROOT}/opencode/plugins/harness-memory/index.ts"
  local plugin_dst="${opencode_dir}/plugins/harness-memory/index.ts"
  local cfg="${opencode_dir}/opencode.json"

  [ -f "$plugin_src" ] || fail "OpenCode plugin template missing: $plugin_src"

  mkdir -p "$(dirname "$plugin_dst")"
  cp "$plugin_src" "$plugin_dst"
  log "Installed OpenCode memory plugin: $plugin_dst"

  upsert_opencode_json "$cfg"
}

check_opencode_wiring() {
  local failed=0
  local cfg="${HOME}/.config/opencode/opencode.json"
  local plugin="${HOME}/.config/opencode/plugins/harness-memory/index.ts"

  if [ ! -f "$plugin" ]; then
    warn "OpenCode memory plugin file missing: $plugin"
    failed=1
  else
    log "OpenCode global plugin: OK"
  fi

  if [ ! -f "$cfg" ]; then
    warn "OpenCode global config missing: $cfg"
    failed=1
  else
    if jq -e '.mcp.harness.enabled == true' "$cfg" >/dev/null 2>&1; then
      log "OpenCode MCP wiring: OK"
    else
      warn "OpenCode config exists but harness MCP wiring is incomplete"
      failed=1
    fi

    log "OpenCode plugin loading: global plugins directory mode"
  fi

  return "$failed"
}

check_claude_wiring() {
  local failed=0
  local hooks="${HARNESS_ROOT}/hooks/hooks.json"
  local mcp_entry="${HARNESS_ROOT}/mcp-server/dist/index.js"
  local found_mcp=0

  if [ ! -f "$hooks" ]; then
    warn "Claude hooks config missing in harness: $hooks"
    failed=1
  elif rg -q 'memory-session-start|memory-user-prompt|memory-post-tool-use|memory-stop' "$hooks"; then
    log "Claude memory hooks in harness plugin: OK"
  else
    warn "Claude hooks found but memory handlers are missing in: $hooks"
    failed=1
  fi

  while IFS= read -r cfg; do
    [ -n "$cfg" ] || continue
    if [ ! -f "$cfg" ]; then
      warn "Claude config missing: $cfg"
      continue
    fi

    if jq -e --arg mcp_entry "$mcp_entry" '
      .mcpServers.harness != null
      and ((.mcpServers.harness.enabled // true) != false)
      and (
        (
          (.mcpServers.harness.command // "") == "node"
          and ((.mcpServers.harness.args // []) | type == "array")
          and ((.mcpServers.harness.args // []) | any(. == $mcp_entry))
        )
        or (
          (.mcpServers.harness.command // "") == "npx"
          and ((.mcpServers.harness.args // []) | any((. | tostring) | contains("harness-mcp-server") or contains("harness-mem")))
        )
      )
    ' "$cfg" >/dev/null 2>&1; then
      log "Claude MCP wiring: OK ($cfg)"
      found_mcp=1
    fi
  done < <(get_claude_config_targets)

  if [ "$found_mcp" -eq 0 ]; then
    warn "Claude MCP wiring is missing or incomplete (expected mcpServers.harness)"
    failed=1
  fi

  return "$failed"
}

start_daemon() {
  HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
    HARNESS_MEM_HOST="$MEM_HOST" \
    HARNESS_MEM_PORT="$MEM_PORT" \
    HARNESS_MEM_DB_PATH="$DB_PATH" \
    "$HARNESS_ROOT/scripts/harness-memd" start --quiet
}

run_smoke() {
  log "Running isolated smoke test"

  (
    set -euo pipefail
    tmp_home=""
    smoke_port=""
    project_name=""
    marker=""
    health=""
    default_search=""
    private_search=""
    cleanup_done=0

    tmp_home="$(mktemp -d)"
    smoke_port="$((40000 + RANDOM % 2000))"
    project_name="$(basename "$TARGET_DIR")"
    marker="smoke-$(date +%s)-$RANDOM"

    cleanup() {
      if [ "$cleanup_done" -eq 0 ]; then
        HARNESS_MEM_HOME="$tmp_home" \
          HARNESS_MEM_DB_PATH="$tmp_home/harness-mem.db" \
          HARNESS_MEM_HOST="127.0.0.1" \
          HARNESS_MEM_PORT="$smoke_port" \
          HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
          "$HARNESS_ROOT/scripts/harness-memd" stop --quiet >/dev/null 2>&1 || true
        rm -rf "$tmp_home"
        cleanup_done=1
      fi
    }

    trap cleanup EXIT

    HARNESS_MEM_HOME="$tmp_home" \
      HARNESS_MEM_DB_PATH="$tmp_home/harness-mem.db" \
      HARNESS_MEM_HOST="127.0.0.1" \
      HARNESS_MEM_PORT="$smoke_port" \
      HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
      "$HARNESS_ROOT/scripts/harness-memd" start --quiet

    health="$(
      HARNESS_MEM_HOME="$tmp_home" \
      HARNESS_MEM_DB_PATH="$tmp_home/harness-mem.db" \
      HARNESS_MEM_HOST="127.0.0.1" \
      HARNESS_MEM_PORT="$smoke_port" \
      HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
      "$HARNESS_ROOT/scripts/harness-mem-client.sh" health
    )"
    printf '%s' "$health" | jq -e '.ok == true' >/dev/null

    jq -nc \
      --arg project "$project_name" \
      --arg marker "$marker" \
      '{event:{platform:"codex",project:$project,session_id:"smoke-session",event_type:"user_prompt",payload:{content:("public " + $marker)},tags:["smoke"],privacy_tags:[]}}' \
      | HARNESS_MEM_HOME="$tmp_home" \
        HARNESS_MEM_DB_PATH="$tmp_home/harness-mem.db" \
        HARNESS_MEM_HOST="127.0.0.1" \
        HARNESS_MEM_PORT="$smoke_port" \
        HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
        "$HARNESS_ROOT/scripts/harness-mem-client.sh" record-event >/dev/null

    jq -nc \
      --arg project "$project_name" \
      --arg marker "$marker" \
      '{event:{platform:"codex",project:$project,session_id:"smoke-session",event_type:"user_prompt",payload:{content:("private " + $marker)},tags:["smoke"],privacy_tags:["private"]}}' \
      | HARNESS_MEM_HOME="$tmp_home" \
        HARNESS_MEM_DB_PATH="$tmp_home/harness-mem.db" \
        HARNESS_MEM_HOST="127.0.0.1" \
        HARNESS_MEM_PORT="$smoke_port" \
        HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
        "$HARNESS_ROOT/scripts/harness-mem-client.sh" record-event >/dev/null

    default_search="$(
      jq -nc --arg q "$marker" --arg project "$project_name" '{query:$q,project:$project,limit:10,include_private:false}' \
        | HARNESS_MEM_HOME="$tmp_home" \
          HARNESS_MEM_DB_PATH="$tmp_home/harness-mem.db" \
          HARNESS_MEM_HOST="127.0.0.1" \
          HARNESS_MEM_PORT="$smoke_port" \
          HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
          "$HARNESS_ROOT/scripts/harness-mem-client.sh" search
    )"
    printf '%s' "$default_search" | jq -e '.ok == true and (.items | length) >= 1' >/dev/null
    printf '%s' "$default_search" | jq -e '[.items[] | (.privacy_tags // []) | index("private")] | map(select(. != null)) | length == 0' >/dev/null

    private_search="$(
      jq -nc --arg q "$marker" --arg project "$project_name" '{query:$q,project:$project,limit:10,include_private:true}' \
        | HARNESS_MEM_HOME="$tmp_home" \
          HARNESS_MEM_DB_PATH="$tmp_home/harness-mem.db" \
          HARNESS_MEM_HOST="127.0.0.1" \
          HARNESS_MEM_PORT="$smoke_port" \
          HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
          "$HARNESS_ROOT/scripts/harness-mem-client.sh" search
    )"
    printf '%s' "$private_search" | jq -e '[.items[] | (.privacy_tags // []) | index("private")] | map(select(. != null)) | length >= 1' >/dev/null
  )

  log "Smoke test: OK"
}

run_quality_tests() {
  local quality_script="${HARNESS_ROOT}/tests/test-memory-search-quality.sh"
  [ -x "$quality_script" ] || fail "Quality test script missing or not executable: $quality_script"
  log "Running search quality test suite"
  "$quality_script"
}

run_import_request() {
  local payload="$1"
  HARNESS_MEM_HOME="$STATE_DIR" \
    HARNESS_MEM_DB_PATH="$DB_PATH" \
    HARNESS_MEM_HOST="$MEM_HOST" \
    HARNESS_MEM_PORT="$MEM_PORT" \
    HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
    "$HARNESS_ROOT/scripts/harness-mem-client.sh" import-claude-mem "$payload"
}

run_verify_request() {
  local payload="$1"
  HARNESS_MEM_HOME="$STATE_DIR" \
    HARNESS_MEM_DB_PATH="$DB_PATH" \
    HARNESS_MEM_HOST="$MEM_HOST" \
    HARNESS_MEM_PORT="$MEM_PORT" \
    HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
    "$HARNESS_ROOT/scripts/harness-mem-client.sh" verify-import "$payload"
}

import_claude_mem_impl() {
  ensure_dependencies
  [ -n "$IMPORT_SOURCE" ] || fail "import-claude-mem requires --source <sqlite path>"
  [ -f "$IMPORT_SOURCE" ] || fail "source db not found: $IMPORT_SOURCE"

  start_daemon

  local payload
  payload="$(jq -nc \
    --arg source "$IMPORT_SOURCE" \
    --arg project "$IMPORT_PROJECT" \
    --argjson dry_run "$([ "$IMPORT_DRY_RUN" -eq 1 ] && echo true || echo false)" \
    '{
      source_db_path: $source,
      dry_run: $dry_run
    } + (if $project == "" then {} else {project: $project} end)')"

  local response
  response="$(run_import_request "$payload")"
  printf '%s\n' "$response"

  echo "$response" | jq -e '.ok == true' >/dev/null || fail "import request failed"
  local job_id
  job_id="$(echo "$response" | jq -r '.items[0].job_id // empty')"
  [ -n "$job_id" ] || fail "import response did not include job_id"
  log "Import job: $job_id"
}

verify_import_impl() {
  ensure_dependencies
  [ -n "$IMPORT_JOB_ID" ] || fail "verify-import requires --job <job_id>"
  start_daemon

  local payload
  payload="$(jq -nc --arg job_id "$IMPORT_JOB_ID" '{job_id: $job_id}')"
  local response
  response="$(run_verify_request "$payload")"
  printf '%s\n' "$response"

  echo "$response" | jq -e '.ok == true' >/dev/null || fail "verify API call failed"
  echo "$response" | jq -e '.items[0].ok == true' >/dev/null || fail "import verification failed"
  log "Import verification passed: $IMPORT_JOB_ID"
}

disable_claude_mem_json_refs() {
  local file="$1"
  [ -f "$file" ] || return 0
  local tmp backup
  tmp="$(mktemp)"
  backup="${file}.pre-harness-cutover.$(date +%s)"
  cp "$file" "$backup" >/dev/null 2>&1 || true

  if jq '
      def scrub:
        if type == "object" then
          with_entries(.value |= scrub)
          | with_entries(
              select(
                (
                  (.value | tostring | ascii_downcase | contains("claude-mem"))
                  or
                  (.key | ascii_downcase | contains("claude-mem"))
                ) | not
              )
            )
        elif type == "array" then
          map(scrub)
          | map(
              select(
                (. | tostring | ascii_downcase | contains("claude-mem")) | not
              )
            )
        else .
        end;
      scrub
    ' "$file" >"$tmp" 2>/dev/null; then
    mv "$tmp" "$file"
    log "Removed claude-mem references from $file (backup: $backup)"
  else
    rm -f "$tmp"
    warn "Could not sanitize $file (invalid JSON?)"
  fi
}

stop_claude_mem_runtime() {
  local stopped=0
  if command -v claude-mem >/dev/null 2>&1; then
    claude-mem stop >/dev/null 2>&1 || true
    stopped=1
  fi

  local pids
  pids="$(pgrep -f '(^|[ /])claude-mem([[:space:]]|$)' || true)"
  if [ -n "$pids" ]; then
    echo "$pids" | while read -r pid; do
      [ -n "$pid" ] || continue
      kill -TERM "$pid" >/dev/null 2>&1 || true
    done
    sleep 1
    local remaining
    remaining="$(pgrep -f '(^|[ /])claude-mem([[:space:]]|$)' || true)"
    if [ -n "$remaining" ]; then
      echo "$remaining" | while read -r pid; do
        [ -n "$pid" ] || continue
        kill -KILL "$pid" >/dev/null 2>&1 || true
      done
    fi
    stopped=1
  fi

  local plist
  for plist in "$HOME"/Library/LaunchAgents/*claude*mem*.plist; do
    [ -e "$plist" ] || continue
    launchctl unload "$plist" >/dev/null 2>&1 || true
    mv "$plist" "${plist}.disabled" >/dev/null 2>&1 || true
    stopped=1
  done

  disable_claude_mem_json_refs "$HOME/.claude/hooks.json"
  disable_claude_mem_json_refs "$HOME/.claude/settings.json"

  if [ "$stopped" -eq 1 ]; then
    log "Claude-mem runtime/autostart disabled"
  else
    warn "No running Claude-mem process or launch agent was found"
  fi
}

cutover_claude_mem_impl() {
  ensure_dependencies
  [ -n "$IMPORT_JOB_ID" ] || fail "cutover-claude-mem requires --job <job_id>"
  [ "$STOP_NOW" -eq 1 ] || fail "cutover requires explicit --stop-now"
  start_daemon

  local payload verify_response
  payload="$(jq -nc --arg job_id "$IMPORT_JOB_ID" '{job_id: $job_id}')"
  verify_response="$(run_verify_request "$payload")"
  echo "$verify_response" | jq -e '.ok == true and .items[0].ok == true' >/dev/null \
    || fail "verify failed; cutover aborted"

  stop_claude_mem_runtime
  log "Cutover completed for job: $IMPORT_JOB_ID"
}

run_setup_claude_mem_import_if_requested() {
  if [ "$SETUP_IMPORT_CLAUDE_MEM" -ne 1 ]; then
    return
  fi

  local source_db="${HOME}/.claude-mem/claude-mem.db"
  [ -f "$source_db" ] || fail "Claude-mem source DB not found: $source_db"

  start_daemon

  local payload response job_id verify_payload verify_response imported_count
  payload="$(jq -nc \
    --arg source "$source_db" \
    '{
      source_db_path: $source,
      dry_run: false
    }')"

  response="$(run_import_request "$payload")"
  echo "$response" | jq -e '.ok == true' >/dev/null || fail "Claude-mem import request failed during setup"

  job_id="$(echo "$response" | jq -r '.items[0].job_id // empty')"
  [ -n "$job_id" ] || fail "Claude-mem import did not return job_id during setup"
  log "Claude-mem import requested (job=${job_id})"

  verify_payload="$(jq -nc --arg job_id "$job_id" '{job_id: $job_id}')"
  verify_response="$(run_verify_request "$verify_payload")"
  echo "$verify_response" | jq -e '.ok == true and .items[0].ok == true' >/dev/null \
    || fail "Claude-mem import verification failed during setup"
  imported_count="$(echo "$verify_response" | jq -r '.items[0].imported_observations // 0')"
  log "Claude-mem import verified (job=${job_id}, imported_observations=${imported_count})"

  if [ "$SETUP_STOP_CLAUDE_MEM_AFTER_IMPORT" -eq 1 ]; then
    stop_claude_mem_runtime
    log "Claude-mem stop completed after setup import"
  fi
}

doctor_impl() {
  local failed=0

  if ! check_cmd bun; then
    warn "bun is missing"
    failed=1
  fi
  if ! check_cmd curl; then
    warn "curl is missing"
    failed=1
  fi
  if ! check_cmd jq; then
    warn "jq is missing"
    failed=1
  fi
  if ! check_cmd node; then
    warn "node is missing"
    failed=1
  fi
  if ! check_cmd npm; then
    warn "npm is missing"
    failed=1
  fi

  if check_cmd bun && check_cmd curl && check_cmd npm; then
    ensure_mcp_runtime || failed=1
    local health_url="http://${MEM_HOST}:${MEM_PORT}/health"
    if curl --silent --show-error --fail --max-time 1 "$health_url" >/dev/null 2>&1; then
      log "Daemon endpoint already reachable: ${health_url}"
    else
      HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
        HARNESS_MEM_HOST="$MEM_HOST" \
        HARNESS_MEM_PORT="$MEM_PORT" \
        HARNESS_MEM_DB_PATH="$DB_PATH" \
        "$HARNESS_ROOT/scripts/harness-memd" start --quiet >/dev/null 2>&1 || true
    fi

    HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
      HARNESS_MEM_HOST="$MEM_HOST" \
      HARNESS_MEM_PORT="$MEM_PORT" \
      HARNESS_MEM_DB_PATH="$DB_PATH" \
      "$HARNESS_ROOT/scripts/harness-memd" cleanup-stale --quiet >/dev/null 2>&1 || true

    if HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
      HARNESS_MEM_HOST="$MEM_HOST" \
      HARNESS_MEM_PORT="$MEM_PORT" \
      HARNESS_MEM_DB_PATH="$DB_PATH" \
      "$HARNESS_ROOT/scripts/harness-memd" doctor >/dev/null; then
      log "Daemon doctor: OK"
    else
      warn "Daemon doctor reported warnings"
      failed=1
    fi
  fi

  if is_platform_enabled codex; then
    check_codex_wiring || failed=1
  fi
  if is_platform_enabled opencode; then
    check_opencode_wiring || failed=1
  fi
  if is_platform_enabled claude; then
    check_claude_wiring || failed=1
  fi
  if is_platform_enabled cursor; then
    check_cursor_wiring || failed=1
  fi
  if is_platform_enabled antigravity; then
    check_antigravity_wiring || failed=1
  fi

  if [ "$failed" -eq 0 ]; then
    log "Doctor result: healthy"
    return 0
  fi

  if [ "$FIX_MODE" -eq 1 ]; then
    warn "Doctor found issues. Running auto-fix."
    setup_impl
    return
  fi

  fail "Doctor found issues. Run with --fix to auto-repair."
}

setup_impl() {
  ensure_dependencies
  ensure_mcp_runtime

  if is_platform_enabled codex; then
    setup_codex_wiring
  fi
  if is_platform_enabled opencode; then
    setup_opencode_wiring
  fi
  if is_platform_enabled claude; then
    setup_claude_wiring
    check_claude_wiring || true
  fi
  if is_platform_enabled cursor; then
    setup_cursor_wiring
  fi
  if is_platform_enabled antigravity; then
    setup_antigravity_wiring
  fi

  if [ "$SKIP_START" -eq 0 ]; then
    start_daemon
    log "Daemon started: http://${MEM_HOST}:${MEM_PORT}"
  fi

  if [ "$SKIP_SMOKE" -eq 0 ]; then
    run_smoke
  fi

  if [ "$SKIP_QUALITY" -eq 0 ]; then
    run_quality_tests
  fi

  run_setup_claude_mem_import_if_requested

  log "Setup complete (project=${TARGET_DIR}, platform=${PLATFORM})"
  print_post_setup_next_steps
}

uninstall_codex_wiring() {
  local cfg="${HOME}/.codex/config.toml"
  local tmp
  if [ ! -f "$cfg" ]; then
    return
  fi

  remove_marked_block "$cfg" "$BEGIN_CODEX_NOTIFY" "$END_CODEX_NOTIFY"
  remove_marked_block "$cfg" "$BEGIN_CODEX_MCP" "$END_CODEX_MCP"
  tmp="$(mktemp)"
  awk '
    /^\[mcp_servers\.harness(\.env)?\]/ { skip = 1; next }
    skip == 1 {
      if ($0 ~ /^\[/) {
        skip = 0
        print $0
      }
      next
    }
    /memory-codex-notify\.sh/ { next }
    { print $0 }
  ' "$cfg" >"$tmp"
  mv "$tmp" "$cfg"
  log "Removed Codex marker-managed wiring: $cfg"
}

remove_opencode_wiring_json() {
  local file="$1"
  local tmp
  if [ ! -f "$file" ]; then
    return
  fi
  tmp="$(mktemp)"
  if jq 'del(.plugins["harness-memory"]) | del(.mcp.harness)' "$file" >"$tmp" 2>/dev/null; then
    mv "$tmp" "$file"
    log "Removed OpenCode memory wiring from: $file"
  else
    rm -f "$tmp"
    warn "Could not parse JSON for cleanup: $file"
  fi
}

remove_claude_wiring_json() {
  local file="$1"
  local tmp
  if [ ! -f "$file" ]; then
    return
  fi
  tmp="$(mktemp)"
  if jq 'if has("mcpServers") then .mcpServers |= del(.harness) else . end' "$file" >"$tmp" 2>/dev/null; then
    mv "$tmp" "$file"
    log "Removed Claude harness MCP wiring from: $file"
  else
    rm -f "$tmp"
    warn "Could not parse JSON for cleanup: $file"
  fi
}

uninstall_claude_wiring() {
  remove_claude_wiring_json "${HOME}/.claude.json"
  remove_claude_wiring_json "${HOME}/.claude/settings.json"
}

uninstall_opencode_wiring() {
  local cfg="${HOME}/.config/opencode/opencode.json"
  local plugin="${HOME}/.config/opencode/plugins/harness-memory/index.ts"

  remove_opencode_wiring_json "$cfg"
  rm -f "$plugin"
  log "Removed OpenCode global memory plugin file: $plugin"
}

uninstall_cursor_wiring() {
  local hooks_json="${HOME}/.cursor/hooks.json"
  local mcp_json="${HOME}/.cursor/mcp.json"
  local tmp
  if [ -f "$hooks_json" ]; then
    tmp="$(mktemp)"
    if jq '
      .hooks = (.hooks // {})
      | .hooks.beforeSubmitPrompt = ((.hooks.beforeSubmitPrompt // []) | map(select(((.command // "") | contains("memory-cursor-event.sh")) | not)))
      | .hooks.afterMCPExecution = ((.hooks.afterMCPExecution // []) | map(select(((.command // "") | contains("memory-cursor-event.sh")) | not)))
      | .hooks.afterShellExecution = ((.hooks.afterShellExecution // []) | map(select(((.command // "") | contains("memory-cursor-event.sh")) | not)))
      | .hooks.afterFileEdit = ((.hooks.afterFileEdit // []) | map(select(((.command // "") | contains("memory-cursor-event.sh")) | not)))
      | .hooks.stop = ((.hooks.stop // []) | map(select(((.command // "") | contains("memory-cursor-event.sh")) | not)))
    ' "$hooks_json" >"$tmp" 2>/dev/null; then
      mv "$tmp" "$hooks_json"
      log "Removed Cursor memory hooks from: $hooks_json"
    else
      rm -f "$tmp"
      warn "Could not parse Cursor hooks JSON for cleanup: $hooks_json"
    fi
  fi

  rm -f "${HOME}/.cursor/hooks/memory-cursor-event.sh"
  log "Removed Cursor memory hook script"

  if [ -f "$mcp_json" ]; then
    tmp="$(mktemp)"
    if jq 'if has("mcpServers") then .mcpServers |= del(.harness) else . end' "$mcp_json" >"$tmp" 2>/dev/null; then
      mv "$tmp" "$mcp_json"
      log "Removed Cursor harness MCP wiring from: $mcp_json"
    else
      rm -f "$tmp"
      warn "Could not parse Cursor MCP JSON for cleanup: $mcp_json"
    fi
  fi
}

uninstall_antigravity_wiring() {
  log "Antigravity wiring cleanup: no project files to remove"
}

uninstall_impl() {
  if check_cmd bun; then
    HARNESS_MEM_CODEX_PROJECT_ROOT="$TARGET_DIR" \
      HARNESS_MEM_HOST="$MEM_HOST" \
      HARNESS_MEM_PORT="$MEM_PORT" \
      HARNESS_MEM_DB_PATH="$DB_PATH" \
      "$HARNESS_ROOT/scripts/harness-memd" stop --quiet >/dev/null 2>&1 || true
  fi

  if is_platform_enabled codex; then
    uninstall_codex_wiring
  fi
  if is_platform_enabled opencode; then
    uninstall_opencode_wiring
  fi
  if is_platform_enabled claude; then
    uninstall_claude_wiring
  fi
  if is_platform_enabled cursor; then
    uninstall_cursor_wiring
  fi
  if is_platform_enabled antigravity; then
    uninstall_antigravity_wiring
  fi

  rm -f "${STATE_DIR}/daemon.pid" "${STATE_DIR}/daemon.lock" "${STATE_DIR}/daemon.heartbeat"
  rm -rf "${STATE_DIR}/runtime"
  log "Removed runtime cache: ${STATE_DIR}/runtime"
  if [ "$PURGE_DB" -eq 1 ]; then
    rm -f "$DB_PATH"
    log "Purged DB: $DB_PATH"
  fi

  log "Uninstall complete (project=${TARGET_DIR}, platform=${PLATFORM})"
}

main() {
  local command="${1:-help}"
  shift || true

  parse_options "$@"
  normalize_ui_lang
  if should_prompt_platform_selection "$command"; then
    prompt_language_selection
    prompt_platform_selection
    SETUP_INTERACTIVE_PROMPT_USED=1
  fi
  if should_prompt_setup_migration_selection "$command"; then
    prompt_setup_migration_selection
  fi

  TARGET_DIR="$(abs_dir "$TARGET_DIR")"

  if should_use_stable_runtime_root; then
    sync_to_stable_runtime_root
  fi

  validate_platform_selection

  case "$command" in
    setup)
      setup_impl
      ;;
    doctor)
      doctor_impl
      ;;
    smoke)
      ensure_dependencies
      ensure_mcp_runtime
      run_smoke
      ;;
    uninstall)
      uninstall_impl
      ;;
    import-claude-mem)
      import_claude_mem_impl
      ;;
    verify-import)
      verify_import_impl
      ;;
    cutover-claude-mem)
      cutover_claude_mem_impl
      ;;
    help|-h|--help)
      usage
      ;;
    *)
      fail "Unknown command: $command"
      ;;
  esac
}

main "$@"
